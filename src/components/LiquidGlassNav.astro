---
import ThemeToggle from "./ThemeToggle.astro";
import lgConfig from "../../liquid-glass-config.json";

interface Props {
    mode?: "floating" | "centered"; // floating for homepage, centered for other pages
}

const { mode = "floating" } = Astro.props;
const currentPath = Astro.url.pathname;

const isActive = (href: string) => {
    if (href === "/") {
        return currentPath === "/";
    }
    return currentPath.startsWith(href);
};

// Serialize config for client-side JavaScript
const lgConfigJson = JSON.stringify(lgConfig);
---

<!-- Removed Tailwind safelist dummy; utilities `hidden` and `md:flex` are present in source files -->

{(mode === "floating" && currentPath === "/") ? (
    <div class="home-island sticky z-20 hidden md:flex">
        <nav
            class="lg-base-pill px-3 py-0.5 border flex items-center gap-1"
      data-lg-island
      data-lg-mode={mode}
      style="position: relative; overflow: visible;"
    >
      <!-- Moving glass selector -->
      <span
          class="lg-glass-selector lg-distort pointer-events-none"
          data-lg-selector
          aria-hidden="true"></span>

      <a
          href="/"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/") },
          ]}
          data-lg-item="true">Home</a
      >
      
      <a
          href="/publications-research-projects"
          class:list={[
              "lg-island-link",
              {
                  "lg-island-link--highlight": isActive(
                      "/publications-research-projects",
                  ),
              },
          ]}
          data-lg-item="true"
      >
          Publications & Projects
      </a>
      <a
          href="/art"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/art") },
          ]}
          data-lg-item="true">Art</a
      >
      <a
          href="/experience"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/experience") },
          ]}
          data-lg-item="true">Experience</a
      >
      

      <div class="relative ml-1 lg-island-link" data-lg-item="true">
          <ThemeToggle />
      </div>
    </nav>
  </div>
) : (mode === "centered" || currentPath !== "/") ? (
    <div class="sticky top-4 z-20 hidden md:flex md:justify-center">
        <nav
            class="lg-base-pill px-3 py-0.5 border flex items-center gap-1"
      data-lg-island
      data-lg-mode={mode}
      style="position: relative; overflow: visible;"
    >
      <!-- Moving glass selector -->
      <span
          class="lg-glass-selector lg-distort pointer-events-none"
          data-lg-selector
          aria-hidden="true"></span>

      <a
          href="/"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/") },
          ]}
          data-lg-item="true">Home</a
      >
      
      <a
          href="/publications-research-projects"
          class:list={[
              "lg-island-link",
              {
                  "lg-island-link--highlight": isActive(
                      "/publications-research-projects",
                  ),
              },
          ]}
          data-lg-item="true"
      >
          Publications, Research &amp; Projects
      </a>
      <a
          href="/art"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/art") },
          ]}
          data-lg-item="true">Art</a
      >
      <a
          href="/experience"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/experience") },
          ]}
          data-lg-item="true">Experience</a
      >
      <a
          href="/resume"
          class:list={[
              "lg-island-link",
              { "lg-island-link--highlight": isActive("/resume") },
          ]}
          data-lg-item="true">Resume</a
      >

      <div class="relative ml-1 lg-island-link" data-lg-item="true">
          <ThemeToggle />
      </div>
    </nav>
  </div>
) : null}

<!-- SVG filter for glass distortion -->
<svg
    width="0"
    height="0"
    aria-hidden="true"
    focusable="false"
    style="position:absolute"
>
    <filter
        id="lg-glass-distort"
        x="-20%"
        y="-20%"
        width="140%"
        height="140%"
        color-interpolation-filters="sRGB"
    >
        <!-- Step 1: Magnification displacement (center zoom) -->
        <feImage
            href="/liquid-glass-magnify.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="magnify_map"
            preserveAspectRatio="none"></feImage>
        <feDisplacementMap
            in="SourceGraphic"
            in2="magnify_map"
            scale={lgConfig.magnification.scale}
            xChannelSelector="R"
            yChannelSelector="G"
            result="magnified"></feDisplacementMap>

        <!-- Step 2: Bezel refraction displacement (edge distortion) -->
        <feImage
            href="/liquid-glass-displacement.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="displacement_map"
            preserveAspectRatio="none"></feImage>
        <feDisplacementMap
            in="magnified"
            in2="displacement_map"
            scale={lgConfig.bezel.scale}
            xChannelSelector="R"
            yChannelSelector="G"
            result="displaced"></feDisplacementMap>

        <!-- Step 3: Specular highlight overlay (smooth gradient) -->
        <feImage
            href="/liquid-glass-specular.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="specular_layer"
            preserveAspectRatio="none"></feImage>
        <feBlend in="specular_layer" in2="displaced" mode="screen"></feBlend>
    </filter>
</svg>

<script is:inline define:vars={{ lgConfigJson, mode }}>
    // Displacement maps are pre-generated by Python script using proper physics

    // Parse config for client-side use
    const lgConfig = JSON.parse(lgConfigJson);

    // Liquid glass selector: smooth mouse-follow + proximity-based text highlighting
    (() => {
        const nav = document.querySelector("[data-lg-island]");
        const selector = document.querySelector("[data-lg-selector]");
        if (!nav || !selector) return;

        // Ensure nav wrapper sits above page content on centered/non-home pages
        try {
            const wrapper = nav.parentElement;
            const navModeAttr = nav.getAttribute("data-lg-mode");
            if (wrapper && navModeAttr === "centered") {
                // Move wrapper into document.body once and keep it synced to nav bounds
                if (!wrapper.__lg_portaled) {
                    // Measure current on-screen rect before changing document flow
                    const initialRect = nav.getBoundingClientRect();

                    // Create a placeholder to preserve layout where the wrapper was
                    try {
                        const placeholder = document.createElement('div');
                        placeholder.style.width = `${initialRect.width}px`;
                        placeholder.style.height = `${initialRect.height}px`;
                        placeholder.style.display = 'block';
                        placeholder.style.pointerEvents = 'none';
                        placeholder.__lg_placeholder = true;
                        const parent = wrapper.parentElement;
                        parent.insertBefore(placeholder, wrapper);

                            // move wrapper into body
                            document.body.appendChild(wrapper);
                            wrapper.__lg_portaled = true;
                            wrapper.__lg_placeholderEl = placeholder;

                            // Apply initial fixed positioning based on measured rect
                            wrapper.style.position = 'fixed';
                            // If centered mode, horizontally center in viewport using 50% + translateX(-50%)
                            if (navModeAttr === 'centered') {
                                wrapper.style.left = '50%';
                                wrapper.style.transform = 'translateX(-50%)';
                                // stick to top for centered (sticky behavior)
                                wrapper.style.top = '16px';
                            } else {
                                wrapper.style.left = `${initialRect.left}px`;
                                wrapper.style.transform = 'none';
                                wrapper.style.top = `${initialRect.top}px`;
                            }
                            wrapper.style.width = `${initialRect.width}px`;
                            wrapper.style.height = `${initialRect.height}px`;
                            wrapper.style.zIndex = '9999';
                            wrapper.style.pointerEvents = 'auto';
                            wrapper.style.background = 'transparent';
                    } catch (err) {
                        console.warn('LG: portaling preparation failed', err);
                    }
                }

                const syncWrapper = () => {
                    // Use placeholder's bounding rect (still in flow) as the source of truth
                    const placeholder = wrapper.__lg_placeholderEl;
                    const sourceRect = placeholder && placeholder.getBoundingClientRect ? placeholder.getBoundingClientRect() : nav.getBoundingClientRect();
                    if (navModeAttr === 'centered') {
                        // keep horizontally centered using translateX(-50%) and left 50%
                        wrapper.style.left = '50%';
                        wrapper.style.transform = 'translateX(-50%)';
                        // sticky to top
                        wrapper.style.top = '16px';
                    } else {
                        wrapper.style.left = `${sourceRect.left}px`;
                        wrapper.style.transform = 'none';
                        wrapper.style.top = `${sourceRect.top}px`;
                    }
                    wrapper.style.width = `${sourceRect.width}px`;
                    wrapper.style.height = `${sourceRect.height}px`;
                };

                syncWrapper();
                window.addEventListener("resize", syncWrapper, { passive: true });
                window.addEventListener("scroll", syncWrapper, { passive: true });
            }
        } catch (err) {
            console.warn('LG: portaling nav failed', err);
        }

        const items = Array.from(nav.querySelectorAll('[data-lg-item="true"]'));
        if (items.length === 0) return;

        // State
        let mouseX = 0,
            mouseY = 0;
        let currentX = 0,
            currentY = 0,
            currentW = 100,
            currentH = 30;
        let targetX = 0,
            targetY = 0,
            targetW = 100,
            targetH = 30;
        let isHovering = false;
        let activeItem = null;
        let raf = null;
        let lockedY = 0; // Y position locked to navbar center

        // Easing/lerp
        const lerp = (start, end, factor) => start + (end - start) * factor;

        // Update CSS variables
        function updateSelectorCSS() {
            selector.style.setProperty("--lg-x", `${currentX}px`);
            selector.style.setProperty("--lg-y", `${currentY}px`);
            selector.style.setProperty("--lg-w", `${currentW}px`);
            selector.style.setProperty("--lg-h", `${currentH}px`);
        }

        // Animation loop (linear interpolation)
        function animate() {
            const smoothness = 0.185;
            currentX = lerp(currentX, targetX, smoothness);
            currentY = lerp(currentY, targetY, smoothness);
            currentW = lerp(currentW, targetW, smoothness);
            currentH = lerp(currentH, targetH, smoothness);

            updateSelectorCSS();

            if (
                Math.abs(currentX - targetX) > 0.01 ||
                Math.abs(currentY - targetY) > 0.01 ||
                Math.abs(currentW - targetW) > 0.01 ||
                Math.abs(currentH - targetH) > 0.01
            ) {
                raf = requestAnimationFrame(animate);
            } else {
                raf = null;
            }
        }

        function startAnimation() {
            if (!raf) {
                raf = requestAnimationFrame(animate);
            }
        }

        // Snap to active item on page load or click
        function snapToActive() {
            // Prefer URL-matching link first, then an explicitly highlighted item, then first item
            const normalize = (s) => (s || "").replace(/\/$/, "");
            const path = normalize(window.location.pathname);

            let activeLink = items.find((a) => {
                if (!a.getAttribute) return false;
                const href = a.getAttribute("href");
                if (!href) return false;
                return normalize(href) === path;
            });

            if (!activeLink) {
                activeLink = nav.querySelector('[data-lg-item="true"].lg-island-link--highlight');
            }

            if (!activeLink) {
                activeLink = items[0];
            }

            if (!activeLink) {
                console.warn('No active item found');
                return;
            }

            const navRect = nav.getBoundingClientRect();
            const itemRect = activeLink.getBoundingClientRect();

            targetX = itemRect.left - navRect.left;
            // make the simple (snapped) selector slightly taller than the link
            const snappedH = itemRect.height + 6;
            targetH = snappedH;
            // If yLock is enabled, center selector on the navbar's vertical center
            if (lgConfig.selector && lgConfig.selector.yLock) {
                const navCenterY = navRect.height / 2;
                targetY = navCenterY - (snappedH / 2);
            } else {
                // center the snapped selector vertically around the item
                targetY = itemRect.top - navRect.top - (snappedH - itemRect.height) / 2;
            }
            targetW = itemRect.width;

            // Store the locked Y position - centered on navbar (used for hover y-lock)
            const navCenterY2 = navRect.height / 2;
            const hoverH = (lgConfig.selector && lgConfig.selector.hoverHeight) || targetH;
            lockedY = navCenterY2 - (hoverH / 2);

            // Instant snap on first load
            currentX = targetX;
            currentY = targetY;
            currentW = targetW;
            currentH = targetH;

            updateSelectorCSS();
            activeItem = activeLink;
            // Ensure text highlight matches the snapped active item
            updateHighlight(activeItem);
        }

        // Find closest item to mouse
        function findClosestItem(mx, my) {
            let minDist = Infinity;
            let closestItem = null;

            for (const item of items) {
                try {
                    const rect = item.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(mx - cx, my - cy);

                    if (dist < minDist) {
                        minDist = dist;
                        closestItem = item;
                    }
                } catch (err) {
                    console.error('LG: findClosestItem error', err);
                    continue;
                }
            }

            return { item: closestItem, distance: minDist };
        }

        // Update text highlight based on proximity
        function updateHighlight(item) {
            try {
                items.forEach((i) => i.classList.toggle("lg-island-link--highlight", i === item));
            } catch (err) {
                console.error('LG: updateHighlight error', err);
            }
        }

        // Mouse move handler - only runs when pointer is over nav (isHovering === true)
        function onMouseMove(e) {
            if (!isHovering) return;

            mouseX = e.clientX;
            mouseY = e.clientY;

            const navRect = nav.getBoundingClientRect();

            targetX = mouseX - navRect.left - lgConfig.selector.hoverWidth / 2;
            if (lgConfig.selector && lgConfig.selector.yLock) {
                const hoverH = (lgConfig.selector && lgConfig.selector.hoverHeight) || targetH;
                targetY = navRect.height / 2 - (hoverH / 2);
            } else {
                targetY = mouseY - navRect.top - lgConfig.selector.hoverHeight / 2;
            }
            targetW = 150;
            targetH = 80;

            let closest = null;
            try {
                const res = findClosestItem(mouseX, mouseY);
                closest = res && res.item;
            } catch (err) {
                console.error('LG: proximity calculation failed', err);
            }

            try {
                updateHighlight(closest);
            } catch (err) {
                console.error('LG: updateHighlight failed', err);
            }

            startAnimation();
        }

        // Snap to active on load
        window.addEventListener("load", snapToActive, { passive: true });

        // Re-snap on resize
        window.addEventListener("resize", snapToActive, { passive: true });

        // Attach pointermove to the nav itself (only processes when isHovering)
        nav.addEventListener("pointermove", onMouseMove, { passive: true });

        // Use nav-level pointer events to detect enter/leave reliably
        nav.addEventListener("pointerenter", (ev) => {
            if (isHovering) return;
            isHovering = true;
            mouseX = ev.clientX;
            mouseY = ev.clientY;
            selector.classList.add("lg-hovering");

            // Immediate update on enter so highlight responds without waiting for mousemove
            const navRect = nav.getBoundingClientRect();
            const navMode = nav.getAttribute("data-lg-mode");
            if (navMode === "centered") {
                if (activeItem) {
                    const itemRect = activeItem.getBoundingClientRect();
                    targetX = itemRect.left - navRect.left;
                    const snappedH = itemRect.height + 6;
                    targetH = snappedH;
                    if (lgConfig.selector && lgConfig.selector.yLock) {
                        const visualYOffset = -3; // px, keep in sync with snapToActive
                        targetY = navRect.height / 2 - (snappedH / 2) + visualYOffset;
                    } else {
                        targetY = itemRect.top - navRect.top - (snappedH - itemRect.height) / 2;
                    }
                    targetW = itemRect.width;
                }
            } else {
                targetX = mouseX - navRect.left - lgConfig.selector.hoverWidth / 2;
                if (lgConfig.selector && lgConfig.selector.yLock) {
                    const hoverH2 = (lgConfig.selector && lgConfig.selector.hoverHeight) || targetH;
                    targetY = navRect.height / 2 - (hoverH2 / 2);
                } else {
                    targetY = mouseY - navRect.top - lgConfig.selector.hoverHeight / 2;
                }
                targetW = 150;
                targetH = 80;
                const { item: closest } = findClosestItem(mouseX, mouseY);
                updateHighlight(closest);
            }
            startAnimation();

            try {
                // best-effort proximity/highlight on enter
                if (navMode !== "centered") {
                    const res = findClosestItem(mouseX, mouseY);
                    updateHighlight(res && res.item);
                }
            } catch (err) {
                console.error('LG: pointerenter proximity failed', err);
            }
        });

        nav.addEventListener("pointerleave", (ev) => {
            if (!isHovering) return;
            isHovering = false;
            mouseX = ev.clientX;
            mouseY = ev.clientY;
            selector.classList.remove("lg-hovering");
            const navRect = nav.getBoundingClientRect();
            const under = document.elementFromPoint(mouseX || 0, mouseY || 0);
            try {
                const rect = under && under.getBoundingClientRect ? under.getBoundingClientRect() : null;
                const cs = under ? window.getComputedStyle(under) : null;
                // Build ancestry list
                const ancestry = [];
                let el = under;
                while (el) {
                    const desc = el.tagName ? el.tagName.toLowerCase() : String(el);
                    const cls = el.className ? (' ' + el.className) : '';
                    ancestry.push(desc + cls + (el.id ? ('#' + el.id) : ''));
                    el = el.parentElement;
                    if (ancestry.length > 12) break;
                }
                console.log('LG: pointerleave', { mouseX, mouseY, navRect, under: under ? under.tagName + ' ' + (under.className||'') : null, underRect: rect, underZ: cs ? cs.zIndex : null, underPointer: cs ? cs.pointerEvents : null, ancestry });
            } catch (err) {
                console.log('LG: pointerleave (under element info failed)', err);
            }
            // Restore active item and snap back
            const activeLink = nav.querySelector('[data-lg-item="true"].lg-island-link--highlight');
            if (activeLink) {
                activeItem = activeLink;
            } else {
                // Try to restore to the link that matches the current pathname
                const normalize = (s) => (s || "").replace(/\/$/, "");
                const path = normalize(window.location.pathname);
                const urlItem = items.find((a) => {
                    const href = a.getAttribute && a.getAttribute("href");
                    if (!href) return false;
                    return normalize(href) === path;
                });
                if (urlItem) {
                    activeItem = urlItem;
                } else {
                    // Fallback to first item (could be the theme button)
                    activeItem = items[0];
                }
            }
            snapToActive();
            startAnimation();
        });

        // Click on nav items - update active and highlight, then snap
        items.forEach((item) => {
            item.addEventListener("click", (ev) => {
                // Instantly snap selector to clicked item to avoid transient animation
                try {
                    selector.style.transition = 'none';
                } catch (e) {}

                activeItem = item;
                // Update highlighting immediately
                items.forEach((i) => i.classList.remove("lg-island-link--highlight"));
                item.classList.add("lg-island-link--highlight");

                snapToActive();

                // Force reflow then restore transitions on next frame
                try { void selector.offsetHeight; } catch (e) {}
                requestAnimationFrame(() => { try { selector.style.transition = ''; } catch (e) {} });
            });
        });

        // Initial snap without animation to avoid left->right jump on load
        try {
            selector.style.transition = 'none';
            snapToActive();
            // Force reflow then restore transitions next frame
            void selector.offsetHeight;
            requestAnimationFrame(() => {
                try { selector.style.transition = ''; } catch (e) {}
            });
        } catch (err) {
            console.error('LG: initial snap failed', err);
        }
    })();
</script>
