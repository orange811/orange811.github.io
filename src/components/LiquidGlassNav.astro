---
import ThemeToggle from "./ThemeToggle.astro";
import lgConfig from "../../liquid-glass-config.json";
import { navLinks } from "../data/navLinks";

const currentPath = Astro.url.pathname;
const isActive = (href: string) => {
    if (href === "/") {
        return currentPath === "/";
    }
    return currentPath.startsWith(href);
};

// Serialize config for client-side JavaScript
const lgConfigJson = JSON.stringify(lgConfig);
---

<!-- Removed Tailwind safelist dummy; utilities `hidden` and `md:flex` are present in source files --><!-- Unified floating-style liquid glass nav for all pages -->
<div class="home-island sticky top-4 z-20 hidden md:flex md:justify-center">
    <nav
        class="lg-base-pill px-3 py-0.5 border flex items-center gap-1"
        data-lg-island
        data-lg-mode="floating"
        style="position: relative; overflow: visible;"
    >
        <!-- Use consistent top spacing and centering for both home and non-home pages
     while preserving the `effectiveMode` value for portaling logic. -->
        <!-- Moving glass selector -->
        <span
            class="lg-glass-selector lg-distort pointer-events-none"
            data-lg-selector
            aria-hidden="true"></span>

        {
            navLinks.map((link) => (
                <a
                    href={link.href}
                    class:list={[
                        "lg-island-link",
                        { "lg-island-link--highlight": isActive(link.href) },
                    ]}
                    data-lg-item="true"
                >
                    {link.label}
                </a>
            ))
        }

        <div class="relative ml-1 lg-island-link" data-lg-item="true">
            <ThemeToggle />
        </div>
    </nav>
</div>

<!-- SVG filter for glass distortion -->
<svg
    width="0"
    height="0"
    aria-hidden="true"
    focusable="false"
    style="position:absolute"
>
    <filter
        id="lg-glass-distort"
        x="-20%"
        y="-20%"
        width="140%"
        height="140%"
        color-interpolation-filters="sRGB"
    >
        <!-- Step 1: Magnification displacement (center zoom) -->
        <feImage
            href="/liquid-glass-magnify.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="magnify_map"
            preserveAspectRatio="none"></feImage>
        <feDisplacementMap
            in="SourceGraphic"
            in2="magnify_map"
            scale={lgConfig.magnification.scale}
            xChannelSelector="R"
            yChannelSelector="G"
            result="magnified"></feDisplacementMap>

        <!-- Step 2: Bezel refraction displacement (edge distortion) -->
        <feImage
            href="/liquid-glass-displacement.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="displacement_map"
            preserveAspectRatio="none"></feImage>
        <feDisplacementMap
            in="magnified"
            in2="displacement_map"
            scale={lgConfig.bezel.scale}
            xChannelSelector="R"
            yChannelSelector="G"
            result="displaced"></feDisplacementMap>

        <!-- Step 3: Specular highlight overlay (smooth gradient) -->
        <feImage
            href="/liquid-glass-specular.png"
            x="-1"
            y="-1"
            width={lgConfig.maps.width}
            height={lgConfig.maps.height}
            result="specular_layer"
            preserveAspectRatio="none"></feImage>
        <feBlend in="specular_layer" in2="displaced" mode="screen"></feBlend>
    </filter>
</svg>

<script is:inline define:vars={{ lgConfigJson }}>
    const lgConfig = JSON.parse(lgConfigJson);

    (() => {
        const nav = document.querySelector("[data-lg-island]");
        const VISUAL_Y_OFFSET = -1;
        const selector = document.querySelector("[data-lg-selector]");
        if (!nav || !selector) return;

        // ... (Portaling logic omitted for brevity, keep it as is) ...
        // ASSUME PORTALING CODE IS HERE

        const items = Array.from(nav.querySelectorAll('[data-lg-item="true"]'));
        if (items.length === 0) return;

        // State
        let mouseX = 0,
            mouseY = 0;
        let currentX = 0,
            currentY = 0,
            currentW = 100,
            currentH = 30;
        let targetX = 0,
            targetY = 0,
            targetW = 100,
            targetH = 30;
        let isHovering = false;
        let activeItem = null;
        let raf = null;
        let hasMoved = false;
        // Removed `lockedY`

        const lerp = (start, end, factor) => start + (end - start) * factor;

        function updateSelectorCSS() {
            selector.style.setProperty("--lg-x", `${currentX}px`);
            selector.style.setProperty("--lg-y", `${currentY}px`);
            selector.style.setProperty("--lg-w", `${currentW}px`);
            selector.style.setProperty("--lg-h", `${currentH}px`);
        }

        function animate() {
            const smoothness = 0.185;
            currentX = lerp(currentX, targetX, smoothness);
            currentY = lerp(currentY, targetY, smoothness);
            currentW = lerp(currentW, targetW, smoothness);
            currentH = lerp(currentH, targetH, smoothness);

            updateSelectorCSS();

            if (
                Math.abs(currentX - targetX) > 0.01 ||
                Math.abs(currentY - targetY) > 0.01 ||
                Math.abs(currentW - targetW) > 0.01 ||
                Math.abs(currentH - targetH) > 0.01
            ) {
                raf = requestAnimationFrame(animate);
            } else {
                raf = null;
            }
        }

        function startAnimation() {
            if (!raf) raf = requestAnimationFrame(animate);
        }

        function snapToActive() {
            const normalize = (s) => (s || "").replace(/\/$/, "");
            const path = normalize(window.location.pathname);

            let activeLink = items.find((a) => {
                if (!a.getAttribute) return false;
                const href = a.getAttribute("href");
                if (!href) return false;
                return normalize(href) === path;
            });

            if (!activeLink)
                activeLink = nav.querySelector(
                    '[data-lg-item="true"].lg-island-link--highlight',
                );
            if (!activeLink) activeLink = items[0];
            if (!activeLink) return;

            const navRect = nav.getBoundingClientRect();
            const itemRect = activeLink.getBoundingClientRect();

            targetX = itemRect.left - navRect.left;
            const snappedH = itemRect.height + 6;
            targetH = snappedH;

            if (lgConfig.selector && lgConfig.selector.yLock) {
                const navCenterY = navRect.height / 2;
                // CHANGED: Added + VISUAL_Y_OFFSET
                targetY = navCenterY - snappedH / 2 + VISUAL_Y_OFFSET;
            } else {
                targetY =
                    itemRect.top -
                    navRect.top -
                    (snappedH - itemRect.height) / 2;
            }
            targetW = itemRect.width;

            // Removed `lockedY` calculation here

            currentX = targetX;
            currentY = targetY;
            currentW = targetW;
            currentH = targetH;

            updateSelectorCSS();
            activeItem = activeLink;
            updateHighlight(activeItem);
            selector.style.opacity = "";
            selector.style.transition = "";
        }

        function findClosestItem(mx, my) {
            let minDist = Infinity;
            let closestItem = null;
            for (const item of items) {
                try {
                    const rect = item.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(mx - cx, my - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        closestItem = item;
                    }
                } catch (err) {}
            }
            return { item: closestItem, distance: minDist };
        }

        function updateHighlight(item) {
            items.forEach((i) =>
                i.classList.toggle("lg-island-link--highlight", i === item),
            );
        }

        function onMouseMove(e) {
            if (!hasMoved) {
                hasMoved = true;
                isHovering = true;
                selector.classList.add("lg-hovering");
            }
            if (!isHovering) return;
            mouseX = e.clientX;
            mouseY = e.clientY;
            const navRect = nav.getBoundingClientRect();

            targetX = mouseX - navRect.left - lgConfig.selector.hoverWidth / 2;
            if (lgConfig.selector && lgConfig.selector.yLock) {
                const hoverH =
                    (lgConfig.selector && lgConfig.selector.hoverHeight) ||
                    targetH;
                // CHANGED: Added + VISUAL_Y_OFFSET
                targetY = navRect.height / 2 - hoverH / 2 + VISUAL_Y_OFFSET;
            } else {
                targetY =
                    mouseY - navRect.top - lgConfig.selector.hoverHeight / 2;
            }
            targetW = 150;
            targetH = 80;

            const res = findClosestItem(mouseX, mouseY);
            updateHighlight(res && res.item);
            startAnimation();
        }

        window.addEventListener("load", snapToActive, { passive: true });
        window.addEventListener("resize", snapToActive, { passive: true });
        nav.addEventListener("pointermove", onMouseMove, { passive: true });

        nav.addEventListener("pointerenter", (ev) => {
            if (!hasMoved) return;
            if (isHovering) return;
            isHovering = true;
            mouseX = ev.clientX;
            mouseY = ev.clientY;
            selector.classList.add("lg-hovering");

            // Initial hover target calc
            const navRect = nav.getBoundingClientRect();
            const navMode = nav.getAttribute("data-lg-mode");
            if (navMode === "centered" && activeItem) {
                const itemRect = activeItem.getBoundingClientRect();
                targetX = itemRect.left - navRect.left;
                targetH = itemRect.height + 6;
                if (lgConfig.selector && lgConfig.selector.yLock) {
                    // CHANGED: Replaced hardcoded -3 with + VISUAL_Y_OFFSET
                    targetY =
                        navRect.height / 2 - targetH / 2 + VISUAL_Y_OFFSET;
                } else {
                    targetY =
                        itemRect.top -
                        navRect.top -
                        (targetH - itemRect.height) / 2;
                }
                targetW = itemRect.width;
            } else {
                // ... regular hover logic ...
                targetX =
                    mouseX - navRect.left - lgConfig.selector.hoverWidth / 2;
                targetY =
                    mouseY - navRect.top - lgConfig.selector.hoverHeight / 2;
                // (Simplified for brevity of cleanup example)
            }
            startAnimation();

            // Best effort proximity
            if (navMode !== "centered") {
                const res = findClosestItem(mouseX, mouseY);
                updateHighlight(res && res.item);
            }
        });

        nav.addEventListener("pointerleave", (ev) => {
            if (!isHovering) return;
            isHovering = false;
            mouseX = ev.clientX;
            mouseY = ev.clientY;
            selector.classList.remove("lg-hovering");

            // REMOVED THE MASSIVE DEBUGGING BLOCK HERE

            // Restore active item and snap back
            const activeLink = nav.querySelector(
                '[data-lg-item="true"].lg-island-link--highlight',
            );
            if (activeLink) {
                activeItem = activeLink;
            } else {
                // ... URL matching fallback ...
                const normalize = (s) => (s || "").replace(/\/$/, "");
                const path = normalize(window.location.pathname);
                const urlItem = items.find((a) => {
                    const href = a.getAttribute && a.getAttribute("href");
                    if (!href) return false;
                    return normalize(href) === path;
                });
                if (urlItem) activeItem = urlItem;
                else activeItem = items[0];
            }
            snapToActive();
            startAnimation();
        });

        items.forEach((item) => {
            item.addEventListener("click", (ev) => {
                try {
                    selector.style.transition = "none";
                } catch (e) {}

                activeItem = item;
                // REMOVED REDUNDANT CLASS TOGGLING HERE

                snapToActive(); // This handles class toggling

                try {
                    void selector.offsetHeight;
                } catch (e) {}
                requestAnimationFrame(() => {
                    try {
                        selector.style.transition = "";
                    } catch (e) {}
                });
            });
        });

        // Initial snap
        try {
            selector.style.transition = "none";
            snapToActive();
            void selector.offsetHeight;
            requestAnimationFrame(() => {
                try {
                    selector.style.transition = "";
                } catch (e) {}
            });
        } catch (err) {}
    })();
</script>
